colnames(bedpe_SVTYPE_classified) <- c("chrom1", "pos1","chrom2","pos2","SVTYPE",
"strand1","strand2",
"ID","ID_mate",
colnames(bedpe)[!(colnames(bedpe) %in% c("chrom1","chrom2","pos1","pos2","strand1","strand2"))])
SVTYPE_stat <- SVTYPE_stat_generate(bedpe_SVTYPE_classified)
return(list(bedpe_SVTYPE_classified, SVTYPE_stat))
}
simple_SVTYPE_classification(vcf_file,"manta")
simple_SVTYPE_classification(vcf_file,"manta")[[1]]
simple_SVTYPE_classification(vcf_file,"manta")[[2]]
#' Classify SV types based on VCF
#'
#' This function read bed format
#'
#' @param vcf_file names of vcf file
#' @param caller_name name of caller to be used in ID
#' @return data frame
#' @export
simple_SVTYPE_classification <- function(vcf_file, caller_name){
bed <- vcf_to_bed(vcf_file)
bedpe <- bed_to_bedpe(bed)
if(length(bedpe$ID_caller)!=0){
bedpe <- bedpe[is.na(match(bedpe$ID_caller, bedpe$INFO_MATEID_caller)) | ### either don't have mate (i.e. not BND)
(c(1:nrow(bedpe)) < match(bedpe$ID_caller, bedpe$INFO_MATEID_caller)),] ###  or present first as BND
}
SV_index <- c(1:nrow(bedpe))
event_index <- SV_index
SVTYPE <- bedpe$INFO_SVTYPE
SVTYPE[bedpe$INFO_SVTYPE == "INS"] <- "INS"
SVTYPE[(bedpe$strand1 == "+") & (bedpe$strand2 == "-") &
(bedpe$chrom1 == bedpe$chrom2) & (bedpe$INFO_SVTYPE != "INS")] <- "DEL"
SVTYPE[(bedpe$strand1 == "-") & (bedpe$strand2 == "+") &
(bedpe$chrom1 == bedpe$chrom2) & (bedpe$INFO_SVTYPE != "INS")] <- "DUP"
SVTYPE[(bedpe$strand1 == bedpe$strand2) &
(bedpe$chrom1 == bedpe$chrom2) &
(bedpe$INFO_SVTYPE != "INS")] <- "INV"
SVTYPE[(bedpe$chrom1 != bedpe$chrom2)] <- "TRA"
SVTYPE[is.na(bedpe$strand1)] <- "INS"
standard_bedpe <- data.frame(chrom1 = as.character(bedpe$chrom1),
pos1 = as.integer(bedpe$pos1),
chrom2 = as.character(bedpe$chrom2),
pos2 = as.integer(bedpe$pos2),
SVTYPE = SVTYPE,
strand1 = bedpe$strand1,
strand2 = bedpe$strand2,
ID = paste0(caller_name,"_",SV_index,"_1_",event_index),
ID_mate = paste0(caller_name,"_",SV_index,"_2_",event_index),
#ALT = bedpe$ALT,
stringsAsFactors = FALSE)
bedpe_SVTYPE_classified <- data.frame(standard_bedpe, bedpe[,!(colnames(bedpe) %in% c("chrom1","chrom2","pos1","pos2","strand1","strand2"))])
colnames(bedpe_SVTYPE_classified) <- c("chrom1", "pos1","chrom2","pos2","SVTYPE",
"strand1","strand2",
"ID","ID_mate",
colnames(bedpe)[!(colnames(bedpe) %in% c("chrom1","chrom2","pos1","pos2","strand1","strand2"))])
SVTYPE_stat <- SVTYPE_stat_generate(bedpe_SVTYPE_classified)
names(SVTYPE_stat) <- vcf_file
return(list(bedpe_SVTYPE_classified, SVTYPE_stat))
}
simple_SVTYPE_classification(vcf_file,"manta")[[2]]
#' Classify SV types based on VCF
#'
#' This function read bed format
#'
#' @param vcf_file names of vcf file
#' @param caller_name name of caller to be used in ID
#' @return data frame
#' @export
simple_SVTYPE_classification <- function(vcf_file, caller_name){
bed <- vcf_to_bed(vcf_file)
bedpe <- bed_to_bedpe(bed)
if(length(bedpe$ID_caller)!=0){
bedpe <- bedpe[is.na(match(bedpe$ID_caller, bedpe$INFO_MATEID_caller)) | ### either don't have mate (i.e. not BND)
(c(1:nrow(bedpe)) < match(bedpe$ID_caller, bedpe$INFO_MATEID_caller)),] ###  or present first as BND
}
SV_index <- c(1:nrow(bedpe))
event_index <- SV_index
SVTYPE <- bedpe$INFO_SVTYPE
SVTYPE[bedpe$INFO_SVTYPE == "INS"] <- "INS"
SVTYPE[(bedpe$strand1 == "+") & (bedpe$strand2 == "-") &
(bedpe$chrom1 == bedpe$chrom2) & (bedpe$INFO_SVTYPE != "INS")] <- "DEL"
SVTYPE[(bedpe$strand1 == "-") & (bedpe$strand2 == "+") &
(bedpe$chrom1 == bedpe$chrom2) & (bedpe$INFO_SVTYPE != "INS")] <- "DUP"
SVTYPE[(bedpe$strand1 == bedpe$strand2) &
(bedpe$chrom1 == bedpe$chrom2) &
(bedpe$INFO_SVTYPE != "INS")] <- "INV"
SVTYPE[(bedpe$chrom1 != bedpe$chrom2)] <- "TRA"
SVTYPE[is.na(bedpe$strand1)] <- "INS"
standard_bedpe <- data.frame(chrom1 = as.character(bedpe$chrom1),
pos1 = as.integer(bedpe$pos1),
chrom2 = as.character(bedpe$chrom2),
pos2 = as.integer(bedpe$pos2),
SVTYPE = SVTYPE,
strand1 = bedpe$strand1,
strand2 = bedpe$strand2,
ID = paste0(caller_name,"_",SV_index,"_1_",event_index),
ID_mate = paste0(caller_name,"_",SV_index,"_2_",event_index),
#ALT = bedpe$ALT,
stringsAsFactors = FALSE)
bedpe_SVTYPE_classified <- data.frame(standard_bedpe, bedpe[,!(colnames(bedpe) %in% c("chrom1","chrom2","pos1","pos2","strand1","strand2"))])
colnames(bedpe_SVTYPE_classified) <- c("chrom1", "pos1","chrom2","pos2","SVTYPE",
"strand1","strand2",
"ID","ID_mate",
colnames(bedpe)[!(colnames(bedpe) %in% c("chrom1","chrom2","pos1","pos2","strand1","strand2"))])
SVTYPE_stat <- SVTYPE_stat_generate(bedpe_SVTYPE_classified)
rownames(SVTYPE_stat) <- vcf_file
return(list(bedpe_SVTYPE_classified, SVTYPE_stat))
}
simple_SVTYPE_classification(vcf_file,"manta")[[2]]
require(parallel)
set.seed(2)
sample_numbers <- sample(10000000, 1000000)
# create cluster object
cl <- makeCluster(3)
# test each number in sample_numbers for primality
results <- parSapply(cl , sample_numbers , is_prime)
# close
stopCluster(cl)
is_prime <- function(num)
{
# if input equals 2 or 3, then we know it's prime
if(num == 2 | num == 3)
return(TRUE)
# if input equals 1, then we know it's not prime
if(num == 1)
return(FALSE)
# else if num is greater than 2
# and divisible by 2, then can't be even
if(num %% 2 == 0)
return(FALSE)
# else use algorithm to figure out
# what factors, if any, input has
# get square root of num, rounded down
root <- floor(sqrt(num))
# try to divide each odd number up to root
# into num; if any leave a remainder of zero,
# then we know num is not prime
for(elt in seq(5,root))
{
if (num %% elt == 0)
return(FALSE)
}
# otherwise, num has no divisors except 1 and itself
# thus, num must be prime
return(TRUE)
}
# create cluster object
cl <- makeCluster(3)
# test each number in sample_numbers for primality
results <- parSapply(cl , 20 , is_prime)
# close
stopCluster(cl)
results
# create cluster object
cl <- makeCluster(3)
# test each number in sample_numbers for primality
results <- parSapply(cl , c(20,30,4), is_prime)
# close
stopCluster(cl)
results
vcf_file
vcf_file1 <- "./inst/extdata/manta_SVEngine_TumorSV2.60x_NormalSV1.60x_0.5.T.PASS.recode.vcf"
vcf_file2 <- "./inst/extdata/manta_SVEngine_TumorSV2.60x_NormalSV1.60x_0.5.T.PASS.recode.vcf"
# create cluster object
cl <- makeCluster(3)
# test each number in sample_numbers for primality
results <- parSapply(cl , c(vcf_file1, vcf_file2), vcf_to_bed)
# close
stopCluster(cl)
results
results[[1]]
View(results)
results[1,]
results[,1]
?parApply
tmp <-results[,1]
unlist(tmp)
matrix(unlist(tmp))
matrix(unlist(tmp),ncol=15)
tmp2<-matrix(unlist(tmp),ncol=15)
View(tmp2)
# create cluster object
cl <- makeCluster(3)
# test each number in sample_numbers for primality
results <- parSapply(cl , c(vcf_file1), vcf_to_bed)
# close
stopCluster(cl)
View(results)
# create cluster object
cl <- makeCluster(3)
# close
stopCluster(cl)
# test each number in sample_numbers for primality
results <- parLapply(cl , c(vcf_file1), vcf_to_bed)
# create cluster object
cl <- makeCluster(3)
# test each number in sample_numbers for primality
results <- parLapply(cl , c(vcf_file1), vcf_to_bed)
# close
stopCluster(cl)
View(results)
results[[1]]
tmp <-results[[1]]
View(tmp)
# create cluster object
cl <- makeCluster(3)
# test each number in sample_numbers for primality
results <- parLapply(cl , c(vcf_file1, vcf_file2), vcf_to_bed)
# close
stopCluster(cl)
tmp <-results[[1]]
tmp <-results[[2]]
View(results)
for(i in c(1:2)){
vcf_file <- c(vcf_file1, vcf_file2)[i]
assign(paste0("bed",i), vcf_to_bed(vcf_file))
}
# create cluster object
cl <- makeCluster(3)
# test each number in sample_numbers for primality
results <- parLapply(cl , c(vcf_file1, vcf_file2), vcf_to_bed)
# close
stopCluster(cl)
start <- proc.time()
# create cluster object
cl <- makeCluster(2)
# test each number in sample_numbers for primality
results <- parLapply(cl , c(vcf_file1, vcf_file2), vcf_to_bed)
end <- proc.time()
print(end - start)
# close
stopCluster(cl)
start <- proc.time()
for(i in c(1:2)){
vcf_file <- c(vcf_file1, vcf_file2)[i]
assign(paste0("bed",i), vcf_to_bed(vcf_file))
}
end <- proc.time()
print(end - start)
start <- proc.time()
results <- sapply(sample_numbers , is_prime)
end <- proc.time()
print(end - start)
detectCores()
?proc.time
start <- proc.time()
# create cluster object
cl <- makeCluster(8)
# close
stopCluster(cl)
end <- proc.time()
print(end - start)
# test each number in sample_numbers for primality
results <- parLapply(cl , c(vcf_file1, vcf_file2), vcf_to_bed)
start <- proc.time()
# create cluster object
cl <- makeCluster(8)
# close
stopCluster(cl)
end <- proc.time()
print(end - start)
# test each number in sample_numbers for primality
results <- parLapply(cl , c(vcf_file1, vcf_file2), vcf_to_bed)
start <- proc.time()
# create cluster object
cl <- makeCluster(8)
# test each number in sample_numbers for primality
results <- parLapply(cl , c(vcf_file1, vcf_file2), vcf_to_bed)
# close
stopCluster(cl)
end <- proc.time()
print(end - start)
start <- proc.time()
for(i in c(1:2)){
vcf_file <- c(vcf_file1, vcf_file2)[i]
assign(paste0("bed",i), vcf_to_bed(vcf_file))
}
end <- proc.time()
print(end - start)
start <- proc.time()
# create cluster object
cl <- makeCluster(8)
# test each number in sample_numbers for primality
results <- parLapply(cl , c(vcf_file1, vcf_file2,vcf_file1, vcf_file2), vcf_to_bed)
# close
stopCluster(cl)
end <- proc.time()
print(end - start)
start <- proc.time()
for(i in c(1:2)){
vcf_file <- c(vcf_file1, vcf_file2,vcf_file1, vcf_file2)[i]
assign(paste0("bed",i), vcf_to_bed(vcf_file))
}
end <- proc.time()
print(end - start)
?dplyr
start <- proc.time()
for(i in c(1:4)){
vcf_file <- c(vcf_file1, vcf_file2,vcf_file1, vcf_file2)[i]
assign(paste0("bed",i), vcf_to_bed(vcf_file))
}
end <- proc.time()
print(end - start)
start <- proc.time()
for(i in c(1:4)){
vcf_file <- c(vcf_file1, vcf_file2,vcf_file1, vcf_file2)[i]
assign(paste0("bed",i), vcf_to_bed(vcf_file))
}
end <- proc.time()
print(end - start)
vcf_list <- c("manta_SVEngine_TumorSV2.60x_NormalSV1.60x_0.5.T.PASS.recode.vcf",
"lumpy_SVEngine_TumorSV2.60x_NormalSV1.60x_0.5_TumorminSU4.vcf",
"delly_SVEngine_TumorSV2.60x_NormalSV1.60x_0.5.somatic.PASS.vcf"
)
usethis::use_data(vcf_list,overwrite = TRUE)
data("vcf_list")
length(vcf_list)
vcf_list[1]
i <- 1
vcf_file <- vcf_list[i]
simple_SVTYPE_classification(vcf_file, caller_name = "Manta")[[2]]
vcf_file1
vcf_file
vcf_file <_ vcf_file1
vcf_file <-vcf_file1
simple_SVTYPE_classification(vcf_file, caller_name = "Manta")[[2]]
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
setwd("~/Desktop/work_at_home/HRPCa_SV_method_paper/TEST_R_script")
################################################################################################################
vcf_list <- c("manta_SVEngine_TumorSV2.60x_NormalSV1.60x_0.5.T.PASS.recode.vcf",
"GRIDSS_SVEngine_TumorSV2.60x_NormalSV1.60x_0.5_somatic_PASS_annotated.vcf")
SVCaller_name <- c("manta","gridss")
sampleID <- "TEST"
BND_diff  <- 2000
bkpt_T_callers <- 200
bedtools_dir <- "/opt/homebrew/bin/bedtools"
start_time <- Sys.time()
SV_integrated <- StructuralVariantUtil::SV_integration(sampleID, SVCaller_name, vcf_list, bkpt_T_callers, SVTYPE_ignore = FALSE, bedtools_dir)
BND_diff <- 2000
directory <- "./"
sub_directory <- paste0("./", paste0(SVCaller_name,collapse = ""))
dir.create(sub_directory)
SVTYPE_ignore_text <- ifelse(SVTYPE_ignore, "SVTYPE_ignore", "SVTYPE_same")
SVCaller_bed_name <- c()
for(i in c(1:length(SVCaller_name))){
results <- StructuralVariantUtil::simple_SVTYPE_classification(vcf_file = vcf_list[i], caller_name = SVCaller_name[i])
tmp <- results[[1]]
tmp <- tmp[tmp$chrom1 %in% paste0("chr", c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,"X","Y")),]
SVCaller_bed_name <- list(SVCaller_bed_name, tmp)
}
SVTYPE_ignore<- FALSE
#SVCaller_bed_name <- paste0(SVCaller_name, "_standard_bedpe")
SVCaller_bed_union <- StructuralVariantUtil::SVCaller_union_intersect_generate(sampleID, SVCaller_name, SVCaller_bed_name, BND_diff, bkpt_T_callers, SVTYPE_ignore, bedtools_dir)
### Each bed, convert to bed_tmp and written to bed_tmp file
for (i in 1:length(SVCaller_name)){
assign(paste0(SVCaller_name[i],"_standard_bedpe"), SVCaller_bed_name[[i]])
#assign(paste0(SVCaller_name[i],"_bed_tmp"), Standard_bedtool_prepare_bkpt(SVCaller_bed_name[[i]],BND_diff))
assign(paste0(SVCaller_name[i],"_bed_tmp"), Standard_bedtool_prepare_bkpt(eval(parse(text=paste0(SVCaller_name[i],"_standard_bedpe"))),BND_diff))
write.table(eval(parse(text=paste0(SVCaller_name[i],"_bed_tmp"))), paste0(sampleID, "_", SVCaller_name[i],"_tmp.bed"), quote=FALSE, sep='\t', row.names=FALSE, col.names=FALSE)
}
manta_standard_bedpe
i
test <- SVCaller_bed_name[[1]]
View(test)
test <- data.frame(SVCaller_bed_name[[1]])
SVCaller_bed_name <- list()
for(i in c(1:length(SVCaller_name))){
results <- simple_SVTYPE_classification(vcf_file = vcf_list[i], caller_name = SVCaller_name[i])
tmp <- results[[1]]
tmp <- tmp[tmp$chrom1 %in% paste0("chr", c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,"X","Y")),]
#assign(paste0(SVCaller_name[i],"_standard_bedpe"), tmp)
SVCaller_bed_name[[i]] <- tmp
}
SVCaller_bed_name <- list()
for(i in c(1:length(SVCaller_name))){
results <- simple_SVTYPE_classification(vcf_file = vcf_list[i], caller_name = SVCaller_name[i])
tmp <- results[[1]]
tmp <- tmp[tmp$chrom1 %in% paste0("chr", c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,"X","Y")),]
#assign(paste0(SVCaller_name[i],"_standard_bedpe"), tmp)
SVCaller_bed_name[[i]] <- tmp
}
SVCaller_bed_name <- list()
for(i in c(1:length(SVCaller_name))){
results <- StructuralVariantUtil::simple_SVTYPE_classification(vcf_file = vcf_list[i], caller_name = SVCaller_name[i])
tmp <- results[[1]]
tmp <- tmp[tmp$chrom1 %in% paste0("chr", c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,"X","Y")),]
#assign(paste0(SVCaller_name[i],"_standard_bedpe"), tmp)
SVCaller_bed_name[[i]] <- tmp
}
#SVCaller_bed_name <- paste0(SVCaller_name, "_standard_bedpe")
SVCaller_bed_union <- StructuralVariantUtil::SVCaller_union_intersect_generate(sampleID, SVCaller_name, SVCaller_bed_name, BND_diff, bkpt_T_callers, SVTYPE_ignore, bedtools_dir)
View(SVCaller_bed_union)
x <- "bedtools"
#' Check the directory of bedtools
#'
#' This function check the binary of bedtools
#'
#' @param x "bedtools"
#' @return data frame
#' @export
Check_bedtools <- function(x = "bedtools"){
# check if binary is in path
if (Sys.which(x) == "") {
cat(paste0('FAIL\n') )
path <- Sys.getenv('PATH')
#if ('' == git.url) {
#   catv(paste0('    It can be downloaded from here: ', git.url, '\n'));
# }
}
else {
cat(paste0('PASS\n    ', Sys.which(x), '\n') )
# return.flag <- TRUE
}
}
Check_bedtools()
#' Check the directory of bedtools
#'
#' This function check the binary of bedtools
#'
#' @param x "bedtools"
#' @return data frame
#' @export
Check_bedtools <- function(x = "bedtools"){
# check if binary is in path
cat(paste0('Checking path for ', x, '... ') );
if (Sys.which(x) == "") {
cat(paste0('FAIL\n') )
path <- Sys.getenv('PATH')
}
else {
cat(paste0('PASS\n    ', Sys.which(x), '\n') )
# return.flag <- TRUE
}
}
Check_bedtools()
Sys.getenv('PATH')
Sys.setenv(PATH = paste(Sys.getenv("PATH"), "/opt/homebrew/bin", sep = ":"))
#' Check the directory of bedtools
#'
#' This function check the binary of bedtools
#'
#' @param x "bedtools"
#' @return data frame
#' @export
Check_bedtools <- function(x = "bedtools"){
# check if binary is in path
cat(paste0('Checking path for ', x, '... ') );
if (Sys.which(x) == "") {
cat(paste0('FAIL\n') )
path <- Sys.getenv('PATH')
}
else {
cat(paste0('PASS\n    ', Sys.which(x), '\n') )
# return.flag <- TRUE
}
}
Sys.getenv('PATH')
Check_bedtools()
#' Check the directory of bedtools
#'
#' This function check the binary of bedtools
#'
#' @param x "bedtools"
#' @return data frame
#' @export
Check_bedtools <- function(x = "bedtools"){
# check if binary is in path
cat(paste0('Checking path for ', x, '... ') );
if (Sys.which(x) == "") {
cat(paste0('FAIL\n') )
path <- Sys.getenv('PATH')
}
else {
cat(paste0('PASS\n    ', Sys.which(x), '\n') )
}
return(Sys.which(x))
}
test <- Check_bedtools()
test
?stopifnot
Sys.getenv('PATH')
#' Check the directory of bedtools
#'
#' This function check the binary of bedtools
#'
#' @param x "bedtools"
#' @return data frame
#' @export
Check_bedtools <- function(x = "bedtools"){
# check if binary is in path
cat(paste0('Checking path for ', x, '... ') );
if (Sys.which(x) == "") {
cat(paste0('FAIL\n') )
#path <- Sys.getenv('PATH')
}
else {
cat(paste0('PASS\n    ', Sys.which(x), '\n') )
}
return(Sys.which(x))
}
test <- Check_bedtools()
Check_bedtools()
Check_bedtools()
?is.NULL
?NULL
?is.null
devtools::document()
devtools::document()
?ggplot
