tmp <- data.frame(bed$INFO_CT, ID_caller = bed$ID_caller)
strand1[tmp$INFO_CT=="3to5"] <- "+"; strand2[tmp$INFO_CT=="3to5"] <- "-"
strand1[tmp$INFO_CT=="5to3"] <- "-"; strand2[tmp$INFO_CT=="5to3"] <- "+"
strand1[tmp$INFO_CT=="3to3"] <- "+"; strand2[tmp$INFO_CT=="3to3"] <- "+"
strand1[tmp$INFO_CT=="5to5"] <- "-"; strand2[tmp$INFO_CT=="5to5"] <- "-"
strand1[tmp$INFO_CT=="NtoN"] <- NA; strand2[tmp$INFO_CT=="NtoN"] <- NA
tmp3 <- cbind(tmp, strand1, strand2)
}else if(sum(!is.na(bed$INFO_INV5)) !=0){
tmp <- data.frame(bed$INFO_INV5, bed$INFO_INV3, ID_caller = bed$ID_caller)
strand1[bed$INFO_INV5] <- "-";strand2[bed$INFO_INV5] <- "-"
strand1[bed$INFO_INV3] <- "+";strand2[bed$INFO_INV3] <- "+"
tmp3 <- cbind(tmp, strand1, strand2)
}else{
tmp3 <- cbind(bed, strand1, strand2)
}
bed2 <- bed[match(tmp3$ID_caller, bed$ID_caller),]
bed2$strand1 <- tmp3$strand1
bed2$strand2 <- tmp3$strand2
if((sum(bed2$INFO_SVTYPE %in% c("DEL","DUP")) != 0) & sum(is.na(bed2$strand1))!=0){
if(length(bed2[is.na(bed2$strand1) & bed2$INFO_SVTYPE == "DEL",]$strand1) != 0){
bed2[is.na(bed2$strand1) & bed2$INFO_SVTYPE == "DEL",]$strand1 <- "+"
bed2[is.na(bed2$strand2) & bed2$INFO_SVTYPE == "DEL",]$strand2 <- "-"
}
if(length(bed2[is.na(bed2$strand1) & bed2$INFO_SVTYPE == "DUP",]$strand1) != 0){
bed2[is.na(bed2$strand1) & bed2$INFO_SVTYPE == "DUP",]$strand1 <- "-"
bed2[is.na(bed2$strand2) & bed2$INFO_SVTYPE == "DUP",]$strand2 <- "+"
}
}
return(bed2)
}
#' Convert bed format to bedpe format
#'
#' This function read bed format
#'
#' @param bed data frame
#' @return data frame
#' @export
bed_to_bedpe <- function(bed){
bed <- strands_standardisation(bed)
ALT <- bed$ALT
tmp <- gsub("\\:.*",'', ALT[grepl('\\[',ALT) | grepl('\\]',ALT)])
tmp1 <- gsub(".*\\[",'', tmp)
tmp2 <- gsub(".*\\]",'', tmp1)
chrom1 = as.character(bed$CHROM)
chrom2 <- chrom1
chrom2[grepl('\\[',ALT) | grepl('\\]',ALT)] <- tmp2
tmp <- gsub(".*\\:",'', ALT[grepl('\\[',ALT) | grepl('\\]',ALT)])
tmp1 <- gsub("\\[.*",'', tmp)
tmp2 <- gsub("\\].*",'', tmp1)
pos2 <- bed$INFO_END
pos2[grepl('\\[',ALT) | grepl('\\]',ALT)] <- tmp2
pos2[is.na(pos2)] <- bed$POS[is.na(pos2)] ###if no POS2 then use #CHROM in VCF
strand1 <- bed$strand1; strand2 <- bed$strand2
###[p[t
strand1[grepl('\\[', bed$ALT) & substr(bed$ALT,1,1) == "["] <- "-"
strand2[grepl('\\[', bed$ALT) & substr(bed$ALT,1,1) == "["] <- "-"
###t[p[
strand1[grepl('\\[', bed$ALT) & substr(bed$ALT,1,1) != "["] <- "+"
strand2[grepl('\\[', bed$ALT) & substr(bed$ALT,1,1) != "["] <- "-"
###t]p]
strand1[grepl(']', bed$ALT) & substr(bed$ALT,1,1) != "]"] <- "+"
strand2[grepl(']', bed$ALT) & substr(bed$ALT,1,1) != "]"] <- "+"
###]p]t
strand1[grepl(']', bed$ALT) & substr(bed$ALT,1,1) == "]"] <- "-"
strand2[grepl(']', bed$ALT) & substr(bed$ALT,1,1) == "]"] <- "+"
bedpe <- data.frame(chrom1=bed$CHROM,
pos1=bed$POS,
chrom2=paste0(tolower(substring(chrom2,1,3)), substring(chrom2,4,nchar(chrom2))),
pos2=pos2,
strand1 = strand1,
strand2 = strand2,
ALT=ALT,
stringsAsFactors = FALSE)
bedpe <- data.frame(bedpe, bed[,!(colnames(bed) %in% c("CHROM","POS","INFO_END","ALT","strand1","strand2"))])
colnames(bedpe) <- c("chrom1", "pos1","chrom2","pos2","strand1","strand2","ALT",
colnames(bed)[!(colnames(bed) %in% c("CHROM","POS","INFO_END","ALT","strand1","strand2"))])
return(bedpe)
}
#' SVtype count
#'
#' This function read bed format
#'
#' @param bedpe bed format
#' @return data frame
#' @export
SVTYPE_stat_generate <- function(bedpe){
All_SVTYPE <- unique(bedpe$SVTYPE)
for(i in c(1: length(All_SVTYPE))){
assign(paste0("N_", All_SVTYPE[i]), sum(bedpe$SVTYPE == All_SVTYPE[i]))
}
STAT_bed <- data.frame(do.call("cbind", lapply(paste0("N_", All_SVTYPE),function(s) eval(parse(text=s)))))
colnames(STAT_bed) <- All_SVTYPE
return(STAT_bed)
}
simple_SVTYPE_classification(vcf_file,"manta")
#' Classify SV types based on VCF
#'
#' This function read bed format
#'
#' @param vcf_file names of vcf file
#' @param caller_name name of caller to be used in ID
#' @return data frame
#' @export
simple_SVTYPE_classification <- function(vcf_file, caller_name){
bed <- vcf_to_bed(vcf_file)
bedpe <- bed_to_bedpe(bed)
if(length(bedpe$ID_caller)!=0){
bedpe <- bedpe[is.na(match(bedpe$ID_caller, bedpe$INFO_MATEID_caller)) | ### either don't have mate (i.e. not BND)
(c(1:nrow(bedpe)) < match(bedpe$ID_caller, bedpe$INFO_MATEID_caller)),] ###  or present first as BND
}
SV_index <- c(1:nrow(bedpe))
event_index <- SV_index
SVTYPE <- bedpe$INFO_SVTYPE
SVTYPE[bedpe$INFO_SVTYPE == "INS"] <- "INS"
SVTYPE[(bedpe$strand1 == "+") & (bedpe$strand2 == "-") &
(bedpe$chrom1 == bedpe$chrom2) & (bedpe$INFO_SVTYPE != "INS")] <- "DEL"
SVTYPE[(bedpe$strand1 == "-") & (bedpe$strand2 == "+") &
(bedpe$chrom1 == bedpe$chrom2) & (bedpe$INFO_SVTYPE != "INS")] <- "DUP"
SVTYPE[(bedpe$strand1 == bedpe$strand2) &
(bedpe$chrom1 == bedpe$chrom2) &
(bedpe$INFO_SVTYPE != "INS")] <- "INV"
SVTYPE[(bedpe$chrom1 != bedpe$chrom2)] <- "TRA"
SVTYPE[is.na(bedpe$strand1)] <- "INS"
standard_bedpe <- data.frame(chrom1 = as.character(bedpe$chrom1),
pos1 = as.integer(bedpe$pos1),
chrom2 = as.character(bedpe$chrom2),
pos2 = as.integer(bedpe$pos2),
SVTYPE = SVTYPE,
strand1 = bedpe$strand1,
strand2 = bedpe$strand2,
ID = paste0(caller_name,"_",SV_index,"_1_",event_index),
ID_mate = paste0(caller_name,"_",SV_index,"_2_",event_index),
#ALT = bedpe$ALT,
stringsAsFactors = FALSE)
bedpe_SVTYPE_classified <- data.frame(standard_bedpe, bedpe[,!(colnames(bedpe) %in% c("chrom1","chrom2","pos1","pos2","strand1","strand2"))])
colnames(bedpe_SVTYPE_classified) <- c("chrom1", "pos1","chrom2","pos2","SVTYPE",
"strand1","strand2",
"ID","ID_mate",
colnames(bedpe)[!(colnames(bedpe) %in% c("chrom1","chrom2","pos1","pos2","strand1","strand2"))])
SVTYPE_stat <- SVTYPE_stat_generate(bedpe_SVTYPE_classified)
return(bedpe_SVTYPE_classified, SVTYPE_stat)
}
simple_SVTYPE_classification(vcf_file,"manta")
simple_SVTYPE_classification(vcf_file,"manta")
#' Classify SV types based on VCF
#'
#' This function read bed format
#'
#' @param vcf_file names of vcf file
#' @param caller_name name of caller to be used in ID
#' @return data frame
#' @export
simple_SVTYPE_classification <- function(vcf_file, caller_name){
bed <- vcf_to_bed(vcf_file)
bedpe <- bed_to_bedpe(bed)
if(length(bedpe$ID_caller)!=0){
bedpe <- bedpe[is.na(match(bedpe$ID_caller, bedpe$INFO_MATEID_caller)) | ### either don't have mate (i.e. not BND)
(c(1:nrow(bedpe)) < match(bedpe$ID_caller, bedpe$INFO_MATEID_caller)),] ###  or present first as BND
}
SV_index <- c(1:nrow(bedpe))
event_index <- SV_index
SVTYPE <- bedpe$INFO_SVTYPE
SVTYPE[bedpe$INFO_SVTYPE == "INS"] <- "INS"
SVTYPE[(bedpe$strand1 == "+") & (bedpe$strand2 == "-") &
(bedpe$chrom1 == bedpe$chrom2) & (bedpe$INFO_SVTYPE != "INS")] <- "DEL"
SVTYPE[(bedpe$strand1 == "-") & (bedpe$strand2 == "+") &
(bedpe$chrom1 == bedpe$chrom2) & (bedpe$INFO_SVTYPE != "INS")] <- "DUP"
SVTYPE[(bedpe$strand1 == bedpe$strand2) &
(bedpe$chrom1 == bedpe$chrom2) &
(bedpe$INFO_SVTYPE != "INS")] <- "INV"
SVTYPE[(bedpe$chrom1 != bedpe$chrom2)] <- "TRA"
SVTYPE[is.na(bedpe$strand1)] <- "INS"
standard_bedpe <- data.frame(chrom1 = as.character(bedpe$chrom1),
pos1 = as.integer(bedpe$pos1),
chrom2 = as.character(bedpe$chrom2),
pos2 = as.integer(bedpe$pos2),
SVTYPE = SVTYPE,
strand1 = bedpe$strand1,
strand2 = bedpe$strand2,
ID = paste0(caller_name,"_",SV_index,"_1_",event_index),
ID_mate = paste0(caller_name,"_",SV_index,"_2_",event_index),
#ALT = bedpe$ALT,
stringsAsFactors = FALSE)
bedpe_SVTYPE_classified <- data.frame(standard_bedpe, bedpe[,!(colnames(bedpe) %in% c("chrom1","chrom2","pos1","pos2","strand1","strand2"))])
colnames(bedpe_SVTYPE_classified) <- c("chrom1", "pos1","chrom2","pos2","SVTYPE",
"strand1","strand2",
"ID","ID_mate",
colnames(bedpe)[!(colnames(bedpe) %in% c("chrom1","chrom2","pos1","pos2","strand1","strand2"))])
SVTYPE_stat <- SVTYPE_stat_generate(bedpe_SVTYPE_classified)
return(list(bedpe_SVTYPE_classified, SVTYPE_stat))
}
simple_SVTYPE_classification(vcf_file,"manta")
simple_SVTYPE_classification(vcf_file,"manta")[[1]]
simple_SVTYPE_classification(vcf_file,"manta")[[2]]
#' Classify SV types based on VCF
#'
#' This function read bed format
#'
#' @param vcf_file names of vcf file
#' @param caller_name name of caller to be used in ID
#' @return data frame
#' @export
simple_SVTYPE_classification <- function(vcf_file, caller_name){
bed <- vcf_to_bed(vcf_file)
bedpe <- bed_to_bedpe(bed)
if(length(bedpe$ID_caller)!=0){
bedpe <- bedpe[is.na(match(bedpe$ID_caller, bedpe$INFO_MATEID_caller)) | ### either don't have mate (i.e. not BND)
(c(1:nrow(bedpe)) < match(bedpe$ID_caller, bedpe$INFO_MATEID_caller)),] ###  or present first as BND
}
SV_index <- c(1:nrow(bedpe))
event_index <- SV_index
SVTYPE <- bedpe$INFO_SVTYPE
SVTYPE[bedpe$INFO_SVTYPE == "INS"] <- "INS"
SVTYPE[(bedpe$strand1 == "+") & (bedpe$strand2 == "-") &
(bedpe$chrom1 == bedpe$chrom2) & (bedpe$INFO_SVTYPE != "INS")] <- "DEL"
SVTYPE[(bedpe$strand1 == "-") & (bedpe$strand2 == "+") &
(bedpe$chrom1 == bedpe$chrom2) & (bedpe$INFO_SVTYPE != "INS")] <- "DUP"
SVTYPE[(bedpe$strand1 == bedpe$strand2) &
(bedpe$chrom1 == bedpe$chrom2) &
(bedpe$INFO_SVTYPE != "INS")] <- "INV"
SVTYPE[(bedpe$chrom1 != bedpe$chrom2)] <- "TRA"
SVTYPE[is.na(bedpe$strand1)] <- "INS"
standard_bedpe <- data.frame(chrom1 = as.character(bedpe$chrom1),
pos1 = as.integer(bedpe$pos1),
chrom2 = as.character(bedpe$chrom2),
pos2 = as.integer(bedpe$pos2),
SVTYPE = SVTYPE,
strand1 = bedpe$strand1,
strand2 = bedpe$strand2,
ID = paste0(caller_name,"_",SV_index,"_1_",event_index),
ID_mate = paste0(caller_name,"_",SV_index,"_2_",event_index),
#ALT = bedpe$ALT,
stringsAsFactors = FALSE)
bedpe_SVTYPE_classified <- data.frame(standard_bedpe, bedpe[,!(colnames(bedpe) %in% c("chrom1","chrom2","pos1","pos2","strand1","strand2"))])
colnames(bedpe_SVTYPE_classified) <- c("chrom1", "pos1","chrom2","pos2","SVTYPE",
"strand1","strand2",
"ID","ID_mate",
colnames(bedpe)[!(colnames(bedpe) %in% c("chrom1","chrom2","pos1","pos2","strand1","strand2"))])
SVTYPE_stat <- SVTYPE_stat_generate(bedpe_SVTYPE_classified)
names(SVTYPE_stat) <- vcf_file
return(list(bedpe_SVTYPE_classified, SVTYPE_stat))
}
simple_SVTYPE_classification(vcf_file,"manta")[[2]]
#' Classify SV types based on VCF
#'
#' This function read bed format
#'
#' @param vcf_file names of vcf file
#' @param caller_name name of caller to be used in ID
#' @return data frame
#' @export
simple_SVTYPE_classification <- function(vcf_file, caller_name){
bed <- vcf_to_bed(vcf_file)
bedpe <- bed_to_bedpe(bed)
if(length(bedpe$ID_caller)!=0){
bedpe <- bedpe[is.na(match(bedpe$ID_caller, bedpe$INFO_MATEID_caller)) | ### either don't have mate (i.e. not BND)
(c(1:nrow(bedpe)) < match(bedpe$ID_caller, bedpe$INFO_MATEID_caller)),] ###  or present first as BND
}
SV_index <- c(1:nrow(bedpe))
event_index <- SV_index
SVTYPE <- bedpe$INFO_SVTYPE
SVTYPE[bedpe$INFO_SVTYPE == "INS"] <- "INS"
SVTYPE[(bedpe$strand1 == "+") & (bedpe$strand2 == "-") &
(bedpe$chrom1 == bedpe$chrom2) & (bedpe$INFO_SVTYPE != "INS")] <- "DEL"
SVTYPE[(bedpe$strand1 == "-") & (bedpe$strand2 == "+") &
(bedpe$chrom1 == bedpe$chrom2) & (bedpe$INFO_SVTYPE != "INS")] <- "DUP"
SVTYPE[(bedpe$strand1 == bedpe$strand2) &
(bedpe$chrom1 == bedpe$chrom2) &
(bedpe$INFO_SVTYPE != "INS")] <- "INV"
SVTYPE[(bedpe$chrom1 != bedpe$chrom2)] <- "TRA"
SVTYPE[is.na(bedpe$strand1)] <- "INS"
standard_bedpe <- data.frame(chrom1 = as.character(bedpe$chrom1),
pos1 = as.integer(bedpe$pos1),
chrom2 = as.character(bedpe$chrom2),
pos2 = as.integer(bedpe$pos2),
SVTYPE = SVTYPE,
strand1 = bedpe$strand1,
strand2 = bedpe$strand2,
ID = paste0(caller_name,"_",SV_index,"_1_",event_index),
ID_mate = paste0(caller_name,"_",SV_index,"_2_",event_index),
#ALT = bedpe$ALT,
stringsAsFactors = FALSE)
bedpe_SVTYPE_classified <- data.frame(standard_bedpe, bedpe[,!(colnames(bedpe) %in% c("chrom1","chrom2","pos1","pos2","strand1","strand2"))])
colnames(bedpe_SVTYPE_classified) <- c("chrom1", "pos1","chrom2","pos2","SVTYPE",
"strand1","strand2",
"ID","ID_mate",
colnames(bedpe)[!(colnames(bedpe) %in% c("chrom1","chrom2","pos1","pos2","strand1","strand2"))])
SVTYPE_stat <- SVTYPE_stat_generate(bedpe_SVTYPE_classified)
rownames(SVTYPE_stat) <- vcf_file
return(list(bedpe_SVTYPE_classified, SVTYPE_stat))
}
simple_SVTYPE_classification(vcf_file,"manta")[[2]]
require(parallel)
set.seed(2)
sample_numbers <- sample(10000000, 1000000)
# create cluster object
cl <- makeCluster(3)
# test each number in sample_numbers for primality
results <- parSapply(cl , sample_numbers , is_prime)
# close
stopCluster(cl)
is_prime <- function(num)
{
# if input equals 2 or 3, then we know it's prime
if(num == 2 | num == 3)
return(TRUE)
# if input equals 1, then we know it's not prime
if(num == 1)
return(FALSE)
# else if num is greater than 2
# and divisible by 2, then can't be even
if(num %% 2 == 0)
return(FALSE)
# else use algorithm to figure out
# what factors, if any, input has
# get square root of num, rounded down
root <- floor(sqrt(num))
# try to divide each odd number up to root
# into num; if any leave a remainder of zero,
# then we know num is not prime
for(elt in seq(5,root))
{
if (num %% elt == 0)
return(FALSE)
}
# otherwise, num has no divisors except 1 and itself
# thus, num must be prime
return(TRUE)
}
# create cluster object
cl <- makeCluster(3)
# test each number in sample_numbers for primality
results <- parSapply(cl , 20 , is_prime)
# close
stopCluster(cl)
results
# create cluster object
cl <- makeCluster(3)
# test each number in sample_numbers for primality
results <- parSapply(cl , c(20,30,4), is_prime)
# close
stopCluster(cl)
results
vcf_file
vcf_file1 <- "./inst/extdata/manta_SVEngine_TumorSV2.60x_NormalSV1.60x_0.5.T.PASS.recode.vcf"
vcf_file2 <- "./inst/extdata/manta_SVEngine_TumorSV2.60x_NormalSV1.60x_0.5.T.PASS.recode.vcf"
# create cluster object
cl <- makeCluster(3)
# test each number in sample_numbers for primality
results <- parSapply(cl , c(vcf_file1, vcf_file2), vcf_to_bed)
# close
stopCluster(cl)
results
results[[1]]
View(results)
results[1,]
results[,1]
?parApply
tmp <-results[,1]
unlist(tmp)
matrix(unlist(tmp))
matrix(unlist(tmp),ncol=15)
tmp2<-matrix(unlist(tmp),ncol=15)
View(tmp2)
# create cluster object
cl <- makeCluster(3)
# test each number in sample_numbers for primality
results <- parSapply(cl , c(vcf_file1), vcf_to_bed)
# close
stopCluster(cl)
View(results)
# create cluster object
cl <- makeCluster(3)
# close
stopCluster(cl)
# test each number in sample_numbers for primality
results <- parLapply(cl , c(vcf_file1), vcf_to_bed)
# create cluster object
cl <- makeCluster(3)
# test each number in sample_numbers for primality
results <- parLapply(cl , c(vcf_file1), vcf_to_bed)
# close
stopCluster(cl)
View(results)
results[[1]]
tmp <-results[[1]]
View(tmp)
# create cluster object
cl <- makeCluster(3)
# test each number in sample_numbers for primality
results <- parLapply(cl , c(vcf_file1, vcf_file2), vcf_to_bed)
# close
stopCluster(cl)
tmp <-results[[1]]
tmp <-results[[2]]
View(results)
for(i in c(1:2)){
vcf_file <- c(vcf_file1, vcf_file2)[i]
assign(paste0("bed",i), vcf_to_bed(vcf_file))
}
# create cluster object
cl <- makeCluster(3)
# test each number in sample_numbers for primality
results <- parLapply(cl , c(vcf_file1, vcf_file2), vcf_to_bed)
# close
stopCluster(cl)
start <- proc.time()
# create cluster object
cl <- makeCluster(2)
# test each number in sample_numbers for primality
results <- parLapply(cl , c(vcf_file1, vcf_file2), vcf_to_bed)
end <- proc.time()
print(end - start)
# close
stopCluster(cl)
start <- proc.time()
for(i in c(1:2)){
vcf_file <- c(vcf_file1, vcf_file2)[i]
assign(paste0("bed",i), vcf_to_bed(vcf_file))
}
end <- proc.time()
print(end - start)
start <- proc.time()
results <- sapply(sample_numbers , is_prime)
end <- proc.time()
print(end - start)
detectCores()
?proc.time
start <- proc.time()
# create cluster object
cl <- makeCluster(8)
# close
stopCluster(cl)
end <- proc.time()
print(end - start)
# test each number in sample_numbers for primality
results <- parLapply(cl , c(vcf_file1, vcf_file2), vcf_to_bed)
start <- proc.time()
# create cluster object
cl <- makeCluster(8)
# close
stopCluster(cl)
end <- proc.time()
print(end - start)
# test each number in sample_numbers for primality
results <- parLapply(cl , c(vcf_file1, vcf_file2), vcf_to_bed)
start <- proc.time()
# create cluster object
cl <- makeCluster(8)
# test each number in sample_numbers for primality
results <- parLapply(cl , c(vcf_file1, vcf_file2), vcf_to_bed)
# close
stopCluster(cl)
end <- proc.time()
print(end - start)
start <- proc.time()
for(i in c(1:2)){
vcf_file <- c(vcf_file1, vcf_file2)[i]
assign(paste0("bed",i), vcf_to_bed(vcf_file))
}
end <- proc.time()
print(end - start)
start <- proc.time()
# create cluster object
cl <- makeCluster(8)
# test each number in sample_numbers for primality
results <- parLapply(cl , c(vcf_file1, vcf_file2,vcf_file1, vcf_file2), vcf_to_bed)
# close
stopCluster(cl)
end <- proc.time()
print(end - start)
start <- proc.time()
for(i in c(1:2)){
vcf_file <- c(vcf_file1, vcf_file2,vcf_file1, vcf_file2)[i]
assign(paste0("bed",i), vcf_to_bed(vcf_file))
}
end <- proc.time()
print(end - start)
?dplyr
start <- proc.time()
for(i in c(1:4)){
vcf_file <- c(vcf_file1, vcf_file2,vcf_file1, vcf_file2)[i]
assign(paste0("bed",i), vcf_to_bed(vcf_file))
}
end <- proc.time()
print(end - start)
start <- proc.time()
for(i in c(1:4)){
vcf_file <- c(vcf_file1, vcf_file2,vcf_file1, vcf_file2)[i]
assign(paste0("bed",i), vcf_to_bed(vcf_file))
}
end <- proc.time()
print(end - start)
vcf_list <- c("manta_SVEngine_TumorSV2.60x_NormalSV1.60x_0.5.T.PASS.recode.vcf",
"lumpy_SVEngine_TumorSV2.60x_NormalSV1.60x_0.5_TumorminSU4.vcf",
"delly_SVEngine_TumorSV2.60x_NormalSV1.60x_0.5.somatic.PASS.vcf"
)
usethis::use_data(vcf_list,overwrite = TRUE)
data("vcf_list")
length(vcf_list)
vcf_list[1]
i <- 1
vcf_file <- vcf_list[i]
simple_SVTYPE_classification(vcf_file, caller_name = "Manta")[[2]]
vcf_file1
vcf_file
vcf_file <_ vcf_file1
vcf_file <-vcf_file1
simple_SVTYPE_classification(vcf_file, caller_name = "Manta")[[2]]
devtools::document()
devtools::document()
devtools::document()
